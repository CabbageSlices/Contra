#ifndef TILE_H_INCLUDED
#define TILE_H_INCLUDED

#include "SFML/Graphics.hpp"
#include "glm/glm.hpp"
#include "PositionController.h"

extern const int TILE_SIZE;

//typedef the position controller incase you want to change to pointer type later
typedef PositionController PositionObject;

enum TileType {

    EMPTY = 0,
    SOLID,
    UPWARD_RIGHT_1_1, //upward slopes collide with bottom of entity
    UPWARD_LEFT_1_1,  //different direction chooses whether it collides with left or right side
    DOWNWARD_RIGHT_1_1, //downward slopes only collide with top of entity
    DOWNWARD_LEFT_1_1, //numbers are absolute value of slope, first number is run, second number is rise
    ONE_WAY,
};

glm::vec2 getSlopeForTileType(const TileType& type) {

    switch(type) {

        case TileType::UPWARD_RIGHT_1_1:
        case TileType::DOWNWARD_LEFT_1_1: {

            return glm::vec2(1, -1);
        }

        case TileType::UPWARD_LEFT_1_1:
        case TileType::DOWNWARD_RIGHT_1_1: {

            return glm::vec2(1, 1);
        }

        default:
            return glm::vec2(1, 0);
    }

    return glm::vec2(1, 0);
}

class Tile {

    public:

        Tile(const glm::vec2 &worldPosition, const glm::vec2 &tileSlope, const TileType& tileType);
        Tile();

        void setType(const TileType& tileType);
        
        //bounding box in world space
        sf::FloatRect getBoundingBox() const;

        void handleCollision(PositionObject& object);
        void draw(sf::RenderWindow& window);
        void drawDebug(sf::RenderWindow& window);

    private:

        void setupEmptyTileColor();

        TileType type;

        //drawing purposes
        sf::RectangleShape tile;
};

#endif // TILE_H_INCLUDED
